

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Overview of CMaize’s User API Design &mdash; CMaize 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Designing CMaize’s Find or Build Dependency Function" href="find_dependencies.html" />
    <link rel="prev" title="Design of CMaize’s User API" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../background/index.html">CMaize Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Developing CMaize</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">CMaize Design Documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../overview.html">Overview of CMaize’s Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="../faq.html">Frequently Asked Design Questions</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Design of CMaize’s User API</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">Overview of CMaize’s User API Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="find_dependencies.html">Designing CMaize’s Find or Build Dependency Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="add_target.html">Designing CMaize’s Add Target Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../classes/index.html">CMaize Class Design</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../assumptions.html">CMaize Assumptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../conventions.html">CMaize Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cmaize_initialization.html">CMaize Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../new_package_manager.html">How to Create a New PackageManager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../design_notes/index.html">Design Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../faqs.html">Developer FAQs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../declaring_targets/index.html">Declaring Build Targets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies/index.html">Declaring Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography/bibliography.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CMaize</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Developing CMaize</a></li>
          <li class="breadcrumb-item"><a href="../index.html">CMaize Design Documentation</a></li>
          <li class="breadcrumb-item"><a href="index.html">Design of CMaize’s User API</a></li>
      <li class="breadcrumb-item active">Overview of CMaize’s User API Design</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/CMakePP/CMaize/edit/master/docs/source/developer/design/user_api/overview.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="overview-of-cmaize-s-user-api-design">
<span id="designing-cmaizes-user-api"></span><h1>Overview of CMaize’s User API Design<a class="headerlink" href="#overview-of-cmaize-s-user-api-design" title="Link to this heading"></a></h1>
<p><a class="reference internal" href="../overview.html#overview-of-cmaizes-design"><span class="std std-ref">Overview of CMaize’s Design</span></a> called for CMaize to have a functional-style
user <a class="reference internal" href="../../../background/terminology.html#term-API"><span class="xref std std-term">API</span></a> written over top of the object-oriented core. This page
describes the design of CMaize’s user API.</p>
<section id="what-is-cmaize-s-user-api">
<h2>What is CMaize’s User API?<a class="headerlink" href="#what-is-cmaize-s-user-api" title="Link to this heading"></a></h2>
<p>To be used as a <a class="reference internal" href="../../../background/terminology.html#term-build-system"><span class="xref std std-term">build system</span></a>, CMaize will provide interfaces for
controlling behavior of the <a class="reference internal" href="../../../background/terminology.html#term-build-phase"><span class="xref std std-term">build phases</span></a>. These interfaces
define the user <a class="reference internal" href="../../../background/terminology.html#term-API"><span class="xref std std-term">API</span></a> of CMaize and determine how the user will
implement their <a class="reference internal" href="../../../background/terminology.html#term-project"><span class="xref std std-term">project’s</span></a><a class="reference internal" href="../../../background/terminology.html#term-build-system"><span class="xref std std-term">build system</span></a>.</p>
</section>
<section id="why-does-cmaize-need-a-user-api">
<h2>Why Does CMaize Need a User API?<a class="headerlink" href="#why-does-cmaize-need-a-user-api" title="Link to this heading"></a></h2>
<p>At a fundamental level, CMaize needs a user API because CMaize will have users
who need to be able to interface with CMaize. The more pertinent
question is, “Why do we need a functional-style user API modeled after CMake?”
To that end, we want to design CMaize’s user <a class="reference internal" href="../../../background/terminology.html#term-API"><span class="xref std std-term">API</span></a> in a manner which
simplifies writing the <a class="reference internal" href="../../../background/terminology.html#term-build-system"><span class="xref std std-term">build system</span></a> for a <a class="reference internal" href="../../../background/terminology.html#term-project"><span class="xref std std-term">project</span></a>. At the
same time, we want to facilitate converting existing CMake-based build
systems to CMaize-based build systems. Since CMake is a functional language,
having a functional-style user API facilitates the conversion.</p>
</section>
<section id="user-api-considerations">
<h2>User API Considerations<a class="headerlink" href="#user-api-considerations" title="Link to this heading"></a></h2>
<dl class="simple" id="ua-cmake-based">
<dt>cmake-based</dt><dd><p>Stemming from the <a class="reference internal" href="../overview.html#cmake-based-build-system"><span class="std std-ref">cmake-based build system</span></a> consideration raised as
part of the design discussions at <a class="reference internal" href="../overview.html#overview-of-cmaizes-design"><span class="std std-ref">Overview of CMaize’s Design</span></a>, it was
decided that the user-facing <a class="reference internal" href="../../../background/terminology.html#term-API"><span class="xref std std-term">API</span></a> of CMaize needed to be written in
traditional CMake.</p>
</dd>
</dl>
<dl class="simple" id="functional-style">
<dt>functional style</dt><dd><p>CMake is a functional-style language. Therefore based on the
<a class="reference internal" href="#ua-cmake-based"><span class="std std-ref">cmake-based</span></a> consideration, the user <a class="reference internal" href="../../../background/terminology.html#term-API"><span class="xref std std-term">API</span></a> should adhere to
functional-style programming.</p>
</dd>
</dl>
<dl id="cmake-to-cmaize">
<dt>CMake to CMaize</dt><dd><p>Somewhat of a corollary to the <a class="reference internal" href="#ua-cmake-based"><span class="std std-ref">cmake-based</span></a>
consideration, user adoption of CMaize is facilitated by having the
conversion from an existing CMake-based build system to a CMaize-based build
system be as easy as possible.</p>
<ul>
<li><p>Generally speaking most CMake <a class="reference internal" href="../../../background/terminology.html#term-build-system"><span class="xref std std-term">build systems</span></a> follow
the same flow:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Declare the <a class="reference internal" href="../../../background/terminology.html#term-project"><span class="xref std std-term">project</span></a>’s meta data including name, version, etc.</p></li>
<li><p>Declare configuration options</p></li>
<li><p>Find the dependencies</p></li>
<li><p>Setup the <a class="reference internal" href="../../../background/terminology.html#term-project"><span class="xref std std-term">project</span></a>’s targets</p></li>
<li><p>Install the targets</p></li>
</ol>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
<dl class="simple" id="ua-minimize-redundancy">
<dt>minimize redundancy</dt><dd><p>One of the motivating considerations for creating CMaize was
<a class="reference internal" href="../overview.html#minimize-redundancy"><span class="std std-ref">minimize redundancy</span></a>. Satisfying this consideration is the job of
CMaize’s user API since ultimately any CMaize-based build system will be
written using the user API.</p>
</dd>
</dl>
<dl class="simple" id="ua-package-manager">
<dt>package manager</dt><dd><p>Building/packaging a dependency/project can be a complicated endeavor. From
<a class="reference internal" href="../overview.html#overview-of-cmaizes-design"><span class="std std-ref">Overview of CMaize’s Design</span></a>, it has been established that CMaize will
have <a class="reference internal" href="../../../background/terminology.html#term-package-manager"><span class="xref std std-term">package manager</span></a> support. In many cases CMaize serves as a
unified API for collecting build system data and shuttling it to the package
manager. It is thus essential that the user API collects all of the data
necessary to drive the package manager.</p>
</dd>
</dl>
</section>
<section id="proposed-user-api">
<h2>Proposed User API<a class="headerlink" href="#proposed-user-api" title="Link to this heading"></a></h2>
<figure class="align-center" id="id1">
<span id="fig-user-api"></span><img alt="../../../_images/user_api.png" src="../../../_images/user_api.png" />
<figcaption>
<p><span class="caption-number">Fig. 2 </span><span class="caption-text">Anticipated control flow of a CMaize-base build system.</span><a class="headerlink" href="#id1" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This section introduces a high-level overview of CMaize’s user API. The
functions comprising the user API are grouped into categories based on the
steps presented in consideration <a class="reference internal" href="#cmake-to-cmaize"><span class="std std-ref">CMake to CMaize</span></a> and shown in
<a class="reference internal" href="#fig-user-api"><span class="std std-numref">Fig. 2</span></a>. Most of the following
subsections are simply summaries of more detailed design discussions (links to
those design discussions are provided) and do not explicitly touch on all
considerations. This is particularly pertinent in the subsections dealing with
declaring and building dependencies and targets.</p>
<section id="project-setup">
<h3>Project Setup<a class="headerlink" href="#project-setup" title="Link to this heading"></a></h3>
<p>Following from the <a class="reference internal" href="#ua-cmake-based"><span class="std std-ref">cmake-based</span></a> consideration, the
build system the user writes with CMaize should be pure CMake and invoked by
running CMake on a <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> file. CMake requires that the first lines
of code be:</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="c"># Ellipses elide project-specific data and are not part of the API.</span>
<span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">...</span><span class="p">)</span>
<span class="nb">project</span><span class="p">(</span><span class="s">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step is to obtain CMaize. This is done through <code class="docutils literal notranslate"><span class="pre">FetchContent</span></code>.
Since CMaize is not in scope yet, obtaining CMaize must be done with the
interfaces provided by traditional CMake and CMaize can not be used to
reduce the boilerplate. The code needed to obtain, and load, CMaize is:</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="nb">include</span><span class="p">(</span><span class="s">FetchContent</span><span class="p">)</span>
<span class="nb">FetchContent_Declare</span><span class="p">(</span>
<span class="w">    </span><span class="s">cmaize</span>
<span class="w">    </span><span class="s">GIT_REPOSITORY</span><span class="w"> </span><span class="s">https://github.com/CMakePP/CMaize</span>
<span class="p">)</span>
<span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">cmaize</span><span class="p">)</span>
<span class="nb">include</span><span class="p">(</span><span class="s">cmaize/cmaize</span><span class="p">)</span>
</pre></div>
</div>
<p>At this point we have CMaize loaded and in scope and encourage the user to use
CMaize’s APIs as much as possible from this point forward. That said, we note
that CMaize will rely on traditional CMake targets, so it is possible to mix
and match traditional CMake and CMaize code.</p>
<p>It is worth noting that the <code class="docutils literal notranslate"><span class="pre">include(cmaize/cmaize)</span></code> line actually initializes
CMaize (full details can be found at <a class="reference internal" href="../../cmaize_initialization.html#cmaize-initialization"><span class="std std-ref">CMaize Initialization</span></a>).</p>
</section>
<section id="build-options">
<h3>Build Options<a class="headerlink" href="#build-options" title="Link to this heading"></a></h3>
<p>The next step for most <a class="reference internal" href="../../../background/terminology.html#term-build-system"><span class="xref std std-term">build systems</span></a> is to define the
<a class="reference internal" href="../../../background/terminology.html#term-build-process"><span class="xref std std-term">build process</span></a> options (beyond those intrinsic to CMake itself). Each
option has three parts:</p>
<ol class="arabic simple">
<li><p>The variable name storing the option’s value.</p></li>
<li><p>A description.</p></li>
<li><p>A default value.</p></li>
</ol>
<p>In traditional CMake, the description is primarily intended for use by CMake’s
<a class="reference internal" href="../../../background/terminology.html#term-GUI"><span class="xref std std-term">GUI</span></a> and the value is restricted to being a boolean. In our experience
users typically build CMake programs through the <a class="reference internal" href="../../../background/terminology.html#term-CLI"><span class="xref std std-term">CLI</span></a>, which makes the
description somewhat of a superfluous input; however, we still see value in
including it in the <a class="reference internal" href="../../../background/terminology.html#term-API"><span class="xref std std-term">API</span></a> because, one, we need it to call CMake’s
<a class="reference external" href="https://cmake.org/cmake/help/latest/command/option.html">option</a> command,
and two, it serves as metadata CMaize can leverage (for example to auto-generate
build documentation). Allowing options to have values, other than boolean, is
useful to avoid having to have a series of options like: <code class="docutils literal notranslate"><span class="pre">enable_vendor0</span></code>,
<code class="docutils literal notranslate"><span class="pre">enable_vendor1</span></code>, <em>etc</em>. Instead the <a class="reference internal" href="../../../background/terminology.html#term-build-system"><span class="xref std std-term">build system</span></a> can simply define a
single option, say <code class="docutils literal notranslate"><span class="pre">vendor</span></code>, which can just be set to a string denoting the
vendor to enable.</p>
<p>With the above considerations in mind, the proposed CMaize API is:</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmaize_option</span><span class="p">(</span><span class="s">enable_feature0</span><span class="w"> </span><span class="s2">&quot;Feature 0 is used to do something&quot;</span><span class="w"> </span><span class="s">FALSE</span><span class="p">)</span>
<span class="nb">cmaize_option</span><span class="p">(</span><span class="s">target_platform</span><span class="w"> </span><span class="s2">&quot;What GPU type to target?&quot;</span><span class="w"> </span><span class="s">NVIDIA</span><span class="p">)</span>
</pre></div>
</div>
<p>Aside from the function name and the fact <code class="docutils literal notranslate"><span class="pre">cmaize_option</span></code> accepts values other
than booleans, the API is identical to the API CMake uses for its <a class="reference external" href="https://cmake.org/cmake/help/latest/command/option.html">option</a>
command. This is by design and stems from the <a class="reference internal" href="#cmake-to-cmaize"><span class="std std-ref">CMake to CMaize</span></a>
consideration.</p>
<p>In addition to <code class="docutils literal notranslate"><span class="pre">cmaize_option</span></code>, we also propose the <code class="docutils literal notranslate"><span class="pre">cmaize_option_list</span></code>
command for setting multiple options at once. Here the motivation is that some
<a class="reference internal" href="../../../background/terminology.html#term-project"><span class="xref std std-term">projects</span></a> need to define many options, which
would lead to many calls to <code class="docutils literal notranslate"><span class="pre">cmaize_option</span></code>. Using
<code class="docutils literal notranslate"><span class="pre">cmaize_option_list</span></code> the above snippet would be:</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmaize_option_list</span><span class="p">(</span>
<span class="w">   </span><span class="s">enable_feature0</span><span class="w"> </span><span class="s2">&quot;Feature 0 is used to do something&quot;</span><span class="w"> </span><span class="s">FALSE</span>
<span class="w">   </span><span class="s">target_platform</span><span class="w"> </span><span class="s2">&quot;What GPU type to target?&quot;</span><span class="w"> </span><span class="s">NVIDIA</span>
<span class="p">)</span>
</pre></div>
</div>
<p>While this won’t necessarily cut down on the number of lines (we still expect
that most build systems will declare one option per line), it is cleaner since
it avoids having to repeat <code class="docutils literal notranslate"><span class="pre">cmaize_option</span></code> on each line. In practice,
<code class="docutils literal notranslate"><span class="pre">cmaize_option_list</span></code> simply wraps looping over “name, description, value”
triples and feeding them to <code class="docutils literal notranslate"><span class="pre">cmaize_option</span></code>.</p>
</section>
<section id="find-dependencies">
<h3>Find Dependencies<a class="headerlink" href="#find-dependencies" title="Link to this heading"></a></h3>
<p>Full discussion: <a class="reference internal" href="find_dependencies.html#designing-cmaize-find-or-build-dependency"><span class="std std-ref">Designing CMaize’s Find or Build Dependency Function</span></a>.</p>
<p>Configuration settings describe many aspects of a build, including what
dependencies are needed. With the configuration options established, the next
step of most builds is to find dependencies. While there a plethora of
edge cases when it comes to finding dependencies, in most cases CMaize “just”
needs to know where to look. CMake already provides mechanisms for users to
provide hints for finding packages (<em>e.g.</em> <code class="docutils literal notranslate"><span class="pre">CMAKE_PREFIX_PATH</span></code>) which CMaize
can leverage. The output of finding a dependency is a CMake target which can be
consumed by other CMake targets.</p>
<p>If a package is not found, a <a class="reference internal" href="../../../background/terminology.html#term-build-system"><span class="xref std std-term">build system</span></a> has two options: error out or
try to build the package. Modern CMake simplifies the process of building
dependencies which also rely on CMake-based build systems (including those using
CMaize-based build systems) through CMake’s
<a class="reference external" href="https://cmake.org/cmake/help/latest/module/FetchContent.html">FetchContent</a>
module. While there
are many edge cases again, generally CMaize can build the
dependency if it knows:</p>
<ul class="simple">
<li><p>where to obtain the dependency from,</p></li>
<li><p>the target version of the dependency,</p></li>
<li><p>values for the configuration options, and</p></li>
<li><p>the package manager to use (if not <a class="reference internal" href="../../../background/cmake_package_manager.html#cmakes-package-manager"><span class="std std-ref">CMake’s Package Manager</span></a>).</p></li>
</ul>
<p>From these considerations, we propose the following user APIs for finding and
building dependencies with CMaize:</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="c"># For building a dependency if it can not be found</span>
<span class="nb">cmaize_find_or_build_dependency</span><span class="p">(</span>
<span class="w">   </span><span class="s">&lt;name&gt;</span>
<span class="w">   </span><span class="s">URL</span><span class="w"> </span><span class="s">&lt;where_on_the_internet_to_download_from&gt;</span>
<span class="w">   </span><span class="s">VERSION</span><span class="w"> </span><span class="s">&lt;the_version_you_want&gt;</span>
<span class="w">   </span><span class="s">BUILD_TARGET</span><span class="w"> </span><span class="s">&lt;target_to_build&gt;</span>
<span class="w">   </span><span class="s">FIND_TARGET</span><span class="w"> </span><span class="s">&lt;target_representing_package&gt;</span>
<span class="w">   </span><span class="s">CMAKE_ARGS</span><span class="w"> </span><span class="s">&lt;configuration_options_to_set&gt;</span>
<span class="p">)</span>

<span class="c">#Or if the build system wants to insist that a dependency must already exist</span>
<span class="nb">cmake_find_dependency</span><span class="p">(</span>
<span class="w">   </span><span class="s">&lt;name&gt;</span>
<span class="w">   </span><span class="s">VERSION</span><span class="w"> </span><span class="s">&lt;the_version_you_want&gt;</span>
<span class="w">   </span><span class="s">FIND_TARGET</span><span class="w"> </span><span class="s">&lt;target_representing_package&gt;</span>
<span class="w">   </span><span class="s">CMAKE_ARGS</span><span class="w"> </span><span class="s">&lt;options_it_should_have_been_configured_with&gt;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>In practice, following from the <a class="reference internal" href="#ua-package-manager"><span class="std std-ref">package manager</span></a> consideration, these
functions are envisioned as wrappers over a <a class="reference internal" href="../../../background/terminology.html#term-package-manager"><span class="xref std std-term">package manager</span></a>. The main
goal of the user API is to collect the information needed for the package
manager to build the dependency and for CMaize to use the dependency the package
manager builds.</p>
</section>
<section id="define-build-targets">
<h3>Define Build Targets<a class="headerlink" href="#define-build-targets" title="Link to this heading"></a></h3>
<p>Full discussion: <a class="reference internal" href="add_target.html#designing-cmaizes-add-target-functions"><span class="std std-ref">Designing CMaize’s Add Target Functions</span></a>.</p>
<p>Once we have found or built all of the <a class="reference internal" href="../../../background/terminology.html#term-project"><span class="xref std std-term">project’s</span></a> dependencies,
we can move on to building the <a class="reference internal" href="../../../background/terminology.html#term-build-target"><span class="xref std std-term">build targets</span></a>. Generally
speaking, the information needed to build a target depends on the coding
language of the target. For the purposes of this high-level discussion, we focus
on C++; build targets for most other coding languages will have similar needs.
For a typical C++ target we need to specify the:</p>
<ul class="simple">
<li><p>name of the build target,</p></li>
<li><p>source files defining the build target’s implementation,</p></li>
<li><p>header files defining the build target’s public <a class="reference internal" href="../../../background/terminology.html#term-API"><span class="xref std std-term">API</span></a>, and</p></li>
<li><p>build target’s dependencies (including other build targets).</p></li>
</ul>
<p>The proposed CMaize APIs are:</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="c"># Declaring a build target for a (C++) library</span>
<span class="nb">cmaize_add_library</span><span class="p">(</span>
<span class="w">   </span><span class="s">&lt;name&gt;</span>
<span class="w">   </span><span class="s">SOURCE_DIR</span><span class="w"> </span><span class="s">&lt;where_the_source_files_are_located&gt;</span>
<span class="w">   </span><span class="s">INCLUDE_DIRS</span><span class="w"> </span><span class="s">&lt;directories_containing_header_files&gt;</span>
<span class="w">   </span><span class="s">DEPENDS</span><span class="w"> </span><span class="s">&lt;dependency0&gt;</span><span class="w"> </span><span class="s">&lt;dependency1&gt;</span><span class="w"> </span><span class="s">...</span>
<span class="p">)</span>

<span class="c"># Declaring a build target for a (C++) executable is similar</span>
<span class="nb">cmaize_add_executable</span><span class="p">(</span>
<span class="w">   </span><span class="s">&lt;name&gt;</span>
<span class="w">   </span><span class="s">SOURCE_DIR</span><span class="w"> </span><span class="s">&lt;where_the_source_files_are_located&gt;</span>
<span class="w">   </span><span class="s">INCLUDE_DIRS</span><span class="w"> </span><span class="s">&lt;directories_containing_header_files&gt;</span>
<span class="w">   </span><span class="s">DEPENDS</span><span class="w"> </span><span class="s">&lt;dependency0&gt;</span><span class="w"> </span><span class="s">&lt;dependency1&gt;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Like the “Find Dependencies” step before it, the APIs for defining build targets
are designed primarily for collecting information pertaining to the build
target. Unlike the “Find Dependencies” step, the backend of API calls for
defining build targets is CMake. The results of calling these methods are
properly configured CMake targets.</p>
</section>
<section id="test-project">
<h3>Test Project<a class="headerlink" href="#test-project" title="Link to this heading"></a></h3>
<p>After targets are built, the next step is to test that they were built correctly.
Testing build targets with CMake often requires:</p>
<ul class="simple">
<li><p>finding dependencies of the testing framework,</p></li>
<li><p>building testing targets which consume the project’s build targets, and</p></li>
<li><p>registering the tests with CTest.</p></li>
</ul>
<p>It is also worth noting that tests are often built conditionally (e.g., a
<a class="reference internal" href="../../../background/terminology.html#term-build-system"><span class="xref std std-term">build system</span></a> typically does not build the tests of dependencies built
during the “Find Dependencies” step). To that end CMake defines the
<code class="docutils literal notranslate"><span class="pre">BUILD_TESTING</span></code> variable; when set to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> tests are built, otherwise they
are not. Proposed CMaize APIs for testing a project:</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmaize_find_or_build_test_dependency</span><span class="p">(</span>
<span class="w">    </span><span class="s">&lt;name&gt;</span>
<span class="w">    </span><span class="s">URL</span><span class="w"> </span><span class="s">&lt;where_on_the_internet_to_download_from&gt;</span>
<span class="w">    </span><span class="s">VERSION</span><span class="w"> </span><span class="s">&lt;the_version_you_want&gt;</span>
<span class="w">    </span><span class="s">BUILD_TARGET</span><span class="w"> </span><span class="s">&lt;target_to_build&gt;</span>
<span class="w">    </span><span class="s">FIND_TARGET</span><span class="w"> </span><span class="s">&lt;target_representing_package&gt;</span>
<span class="w">    </span><span class="s">CMAKE_ARGS</span><span class="w"> </span><span class="s">&lt;configuration_options_to_set&gt;</span>
<span class="p">)</span>

<span class="nb">cmaize_add_test_library</span><span class="p">(</span>
<span class="w">    </span><span class="s">&lt;name&gt;</span>
<span class="w">    </span><span class="s">SOURCE_DIR</span><span class="w"> </span><span class="s">&lt;where_the_source_files_are_located&gt;</span>
<span class="w">    </span><span class="s">INCLUDE_DIRS</span><span class="w"> </span><span class="s">&lt;directories_containing_header_files&gt;</span>
<span class="w">    </span><span class="s">DEPENDS</span><span class="w"> </span><span class="s">&lt;dependency0&gt;</span><span class="w"> </span><span class="s">&lt;dependency1&gt;</span><span class="w"> </span><span class="s">...</span>
<span class="p">)</span>

<span class="nb">cmaize_add_test_executable</span><span class="p">(</span>
<span class="w">    </span><span class="s">&lt;name&gt;</span>
<span class="w">    </span><span class="s">SOURCE_DIR</span><span class="w"> </span><span class="s">&lt;where_the_source_files_are_located&gt;</span>
<span class="w">    </span><span class="s">INCLUDE_DIRS</span><span class="w"> </span><span class="s">&lt;directories_containing_header_files&gt;</span>
<span class="w">    </span><span class="s">DEPENDS</span><span class="w"> </span><span class="s">&lt;dependency0&gt;</span><span class="w"> </span><span class="s">&lt;dependency1&gt;</span><span class="w"> </span><span class="s">...</span>
<span class="p">)</span>

<span class="c"># This is actually CTest&#39;s add_test command</span>
<span class="nb">add_test</span><span class="p">(</span><span class="s">NAME</span><span class="w"> </span><span class="s">&lt;name&gt;</span><span class="w"> </span><span class="s">COMMAND</span><span class="p">)</span>

<span class="c"># This is a convenience function for the common scenario where the</span>
<span class="c"># add_test call simply calls the executable arising from the</span>
<span class="c"># cmaize_add_test_executable</span>
<span class="nb">cmaize_add_test</span><span class="p">(</span>
<span class="w">    </span><span class="s">&lt;name&gt;</span>
<span class="w">    </span><span class="s">SOURCE_DIR</span><span class="w"> </span><span class="s">&lt;where_the_source_files_are_located&gt;</span>
<span class="w">    </span><span class="s">INCLUDE_DIRS</span><span class="w"> </span><span class="s">&lt;directories_containing_header_files&gt;</span>
<span class="w">    </span><span class="s">DEPENDS</span><span class="w"> </span><span class="s">&lt;dependency0&gt;</span><span class="w"> </span><span class="s">&lt;dependency1&gt;</span><span class="w"> </span><span class="s">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>All of the test functions are thin wrappers around the non-test functions of
the same name (e.g., <code class="docutils literal notranslate"><span class="pre">cmaize_add_test_library</span></code> wraps <code class="docutils literal notranslate"><span class="pre">cmaize_add_library</span></code>),
which hide the logic for including the CTest CMake module, and checking that
<code class="docutils literal notranslate"><span class="pre">BUILD_TESTING</span></code> is enabled (if it’s not the functions are no-ops).</p>
</section>
<section id="install-project">
<h3>Install Project<a class="headerlink" href="#install-project" title="Link to this heading"></a></h3>
<p>If the tests are successful (or were skipped), the next step is <a class="reference internal" href="../../../background/terminology.html#term-package"><span class="xref std std-term">package</span></a>
installation. Installation typically requires specifying which targets are
part of the package, generating the packaging files, and then
moving the targets and files to their final location. The main considerations
for installing are:</p>
<ul>
<li><p>Collecting sufficient information to be able to install the package including:</p>
<blockquote>
<div><ul class="simple">
<li><p>where it goes,</p></li>
<li><p>which pieces get installed, and</p></li>
<li><p>what the runtime dependencies are.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Installation should be done in a manner which considers the package manager.</p></li>
</ul>
<p>The proposed installation <a class="reference internal" href="../../../background/terminology.html#term-API"><span class="xref std std-term">API</span></a> is:</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmaize_add_package</span><span class="p">(</span>
<span class="w">    </span><span class="s">&lt;name&gt;</span>
<span class="w">    </span><span class="s">NAMESPACE</span><span class="w"> </span><span class="s">&lt;namespace&gt;</span>
<span class="w">    </span><span class="s">TARGETS</span><span class="w"> </span><span class="s">&lt;target0&gt;</span><span class="w"> </span><span class="s">&lt;target1&gt;</span><span class="w"> </span><span class="s">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Each of the user API calls proceeding <code class="docutils literal notranslate"><span class="pre">cmaize_add_package</span></code> record the
information provided. In turn when it comes time to write the packaging files
and install the package, CMaize can do so in a largely automatic manner simply
by inspecting the information which was already provided. If the user wants to
fine-tune the package installation there are a number of options they can supply
including:</p>
<ul class="simple">
<li><p>the namespace to use in the package files (CMake allows prepending a prefix to
an installed target’s name to avoid naming collisions), and</p></li>
<li><p>the specific targets to install (by default only the target with the same
name as <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> is installed).</p></li>
</ul>
</section>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Link to this heading"></a></h2>
<dl class="simple">
<dt><a class="reference internal" href="#ua-cmake-based"><span class="std std-ref">cmake-based</span></a></dt><dd><p>CMaize’s user <a class="reference internal" href="../../../background/terminology.html#term-API"><span class="xref std std-term">API</span></a> is designed to be invoked directly from the
<a class="reference internal" href="../../../background/terminology.html#term-project"><span class="xref std std-term">project’s</span></a> <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> as part of the usual CMake
build procedure.</p>
</dd>
<dt><a class="reference internal" href="#functional-style"><span class="std std-ref">functional style</span></a></dt><dd><p>All user-facing APIs are designed to be functional in nature so as to
seamlessly integrate with traditional CMake-based build systems.</p>
</dd>
<dt><a class="reference internal" href="#cmake-to-cmaize"><span class="std std-ref">CMake to CMaize</span></a></dt><dd><p>Where possible the user-facing CMaize APIs rely on the same keywords and
structure as the CMake APIs they wrap. Converting a CMake-based build system
to a CMaize-based build system, should therefore almost be a refactoring
effort as opposed to a complete rewrite.</p>
</dd>
<dt><a class="reference internal" href="#ua-minimize-redundancy"><span class="std std-ref">minimize redundancy</span></a></dt><dd><p>We have specifically designed the CMaize API to be as succinct as possible
by relying on intelligent defaults and recording information. The latter is
in particular very important for minimizing redundancy as a lot of CMake’s
verbosity comes from having to resupply the same information to many
different function calls.</p>
</dd>
<dt><a class="reference internal" href="#ua-package-manager"><span class="std std-ref">package manager</span></a></dt><dd><p>Most of the user APIs wrap interactions with a <a class="reference internal" href="../../../background/terminology.html#term-package-manager"><span class="xref std std-term">package manager</span></a>. It is
the package manager which does the heavy lifting of finding, building, and
installing dependencies and/or build <a class="reference internal" href="../../../background/terminology.html#term-build-target"><span class="xref std std-term">build targets</span></a>.</p>
</dd>
</dl>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Design of CMaize’s User API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="find_dependencies.html" class="btn btn-neutral float-right" title="Designing CMaize’s Find or Build Dependency Function" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, CMakePP Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>